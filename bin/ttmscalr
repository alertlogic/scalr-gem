#!/usr/bin/env ruby

require 'pathname'
bin_path = Pathname.new(__FILE__).realpath
$:.unshift File.expand_path('../../lib', bin_path)

require 'date'
require 'json'
require 'main'
require 'scalr'
require 'scalr/ttm'
require 'scalr/caller'
require 'scalr/deployer'

Scalr.read_access_info
#Scalr.debug = $stderr

def generic_error(response)
  return true unless response
  return false if response.success?
  $stderr.puts("ERROR - #{response.error}]")
  true
end

def logging_options(main)
  main.option 'farm, -a' do
    argument :required
    description 'Farm with logs'
  end
  main.option 'server' do
    argument :optional
    description 'Server to restrict logs from'
  end
  main.option 'start' do
    argument :optional
    cast :int
    description 'Log count to start with'
  end
  main.option 'limit' do
    argument :optional
    cast :int
    description 'Log entries to fetch'
  end
end

# this is kind of gross -- the response has a status, but it's really just
# indicating "yeah I executed your script" -- instead, you have to look at the scripting
# log for each of the servers you executed against and check the exit code...
# AND
# we have to do so in a loop, as 'async' doesn't mean what you think it means...
def poll_for_script_logs(options)
  expected_server_count = options[:servers] ? options[:servers].length : 0

  script_time = options[:script_time]
  script_name = options[:script]
  script_log_options = {farm_id: options[:farm_id]}

  max_polls = 5
  count = 1

  matching_logs = []

  loop do
    break if count > max_polls
    break if expected_server_count != 0 && matching_logs.length == expected_server_count
    break if expected_server_count == 0 && matching_logs.length > 0

    print '.'
    sleep(5)

    log_response = invoke(:script_logs_list, script_log_options)
    if generic_error(log_response)
      raise 'Failed to fetch logs to display the scripting error. Check scalr website: https://my.scalr.com/#/logs/scripting'
    end
    matching_logs = log_response.content.find_all do |log_item|
      log_item.after?(script_time) && log_item.script_matches(script_name)
    end
    count += 1
  end

  print "\n"
  matching_logs
end

def dispatch(action_name, params)
  Scalr::Caller.new(action_name).dispatch(params)
end

def invoke(action_name, options = {})
  Scalr::Caller.new(action_name).invoke(options)
end

# implementation notes:
# - Main seems to dispatch on mode-names in first-match order. So you'll need
#   to have a mode 'deploy' before a mode 'deploy:log', otherwise it will never
#   get invoked. So least-specific modes should be before most-specific.
Main {
  description <<-DESC
    Command-line interface for Scalr, with TTM-specific additions which make it
    look more like the heroku application. See README.md for more.
  DESC

  ########## Deployment

  mode 'deploy' do
    description 'Deploy an application to all roles within a farm.'

    argument 'application' do
      description 'Application ID/alias to deploy. (Use "application:list" to list.)'
    end
    option 'farm, -a' do
      argument :optional
      description 'Farm to use when resolving role (if aliased)'
    end
    option 'path' do
      argument :optional
      description 'Path to which the application will be deployed (rarely needed)'
    end
    option 'verbose' do
      description 'false (default): display information only when all tasks done; true: display data as we poll'
    end

    def run
      options = Scalr::Caller.collect_options(params, [:farm_id, :application_id, :remote_path])
      options[:verbose] = params['verbose'].value
      Scalr::Deployer.new(options).execute
    end
  end

  mode 'deploy:monitor' do
    argument 'application' do
      description 'Application ID/alias to deploy. (Use "application:list" to list.)'
    end
    option 'farm, -a' do
      argument :optional
      description 'Farm to use when resolving role (if aliased)'
    end
    option 'task' do
      argument :required
      arity -1
      description 'One or more tasks that are already running'
    end

    def run
      options = Scalr::Caller.collect_options(params, [:farm_id, :application_id, :remote_path])
      deployer = Scalr::Deployer.new(options)
      deployer.initialize_monitors

      # fetch given tasks and pass them to the deployer,
      # letting it figure out which monitor each task should go to

      deployer.poll_monitors
    end
  end

  mode 'deploy:tasks' do
    option 'application' do
      argument :optional
      description 'ID of application'
    end
    option 'farm, -a' do
      argument :optional
      description 'Farm to display tasks for'
    end
    option 'role, -r' do
      argument :optional
      description 'Restrict results to tasks on a particular role in the farm'
    end
    option 'server' do
      argument :optional
      description 'Restrict results to tasks on a particular server'
    end

    def run
      response = dispatch(:dm_deployment_tasks_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'No task records.'
      else
        puts Scalr::ResponseObject::DeploymentTaskItem.
                 show_items(response.content).join("\n")
      end
    end
  end

  mode 'task' do
    argument 'task' do
      description 'ID of deployment task (use "deploy:tasks" + farm and role to lookup)'
    end

    def run
      response = dispatch(:dm_deployment_task_get_status, params)
      return if generic_error(response)

      puts "Status: #{response.content}"

      response = dispatch(:dm_deployment_task_get_log, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
      else
        response.content.each do |log_item|
          puts "#{log_item.timestamp_formatted} - #{log_item.message_trimmed}"
        end
      end
    end
  end

  mode 'maintenance' do
    argument 'mode' do
      description 'Either "on" or "off" to enable/disable maintenance mode'
      validate {|mode| mode.match(/^(on|off)$/)}
    end
    option 'farm, -a' do
      argument :required
      description 'Farm we will put into maintenance mode'
    end
    option 'role, -r' do
      argument :optional
      description 'Specific role we will put into maintenance, defaults to "rails"'
      default 'rails'
    end
    option 'script' do
      argument :optional
      description 'Script to execute, defaults to "TTMMaintenanceMode" (should not need to change)'
      default 'TTMMaintenanceMode'
    end

    def run
      options = Scalr::Caller.collect_options(params, [:farm_id, :farm_role_id, :script_id])

      # fetch the role we'll execute in so we can count servers + resolve server IDs
      role_response = invoke(:farm_get_details, farm_id: options[:farm_id])
      exec_role = role_response.content.find {|role| role.id.to_s == options[:farm_role_id].to_s}
      raise 'Cannot determine role script executes in - weird!' unless exec_role

      options[:config_variables] = {on_or_off: params['mode'].value}
      options[:async] = '0'

      script_time = Time.now
      response = invoke(:script_execute, options)
      return if generic_error(response)

      puts "Script executed... polling for logs from #{exec_role.servers_running.length} servers."

      logs = poll_for_script_logs(farm_id: options[:farm_id], script: params['script'].value,
                                  script_time: script_time, servers: exec_role.servers_running)

      exec_ok = logs.find_all {|log_item| log_item.success?}
      unless exec_ok.empty?
        puts "OK - Maintenance: #{params['mode'].value} (#{exec_ok.length} of #{logs.length} servers)"
      end
      return if exec_ok.length == logs.length

      role_name = params['role'].value # show what the user gave us...

      exec_fail = logs.find_all {|log_item| log_item.failure?}
      puts "FAIL (#{exec_fail.length} of #{logs.length} servers)."
      exec_fail.each do |log_item|
        server = exec_role.find_server(log_item.server_id)
        server_display = server.nil? ? log_item.server_id : "#{role_name}.#{server.index}"
        puts "#{server_display} => exit code: #{log_item.exit_code}"
        puts log_item.message, "\n"
      end
    end
  end

  mode 'log:script' do
    logging_options(self)

    option 'role, -r' do
      argument :optional
    end
    option 'expand' do
      argument :optional
      description 'Display full messages generated by this script only'
    end
    option 'quiet' do
      description 'false (default) display failures and "expand"-triggered messages, true means only display status for all'
    end
    option 'verbose' do
      description 'false (default) means only display failures, true means display all'
    end

    def run
      response = dispatch(:script_logs_list, params)
      return if generic_error(response)

      expand_script = params['expand'].given? ? params['expand'].value : nil

      display_all = params['verbose'].value
      puts "Script logs -- displaying #{display_all ? 'all records' : 'only failures'}", "\n"
      to_display = display_all ? response.content : response.content.find_all {|log_item| log_item.failure?}

      puts Scalr::ResponseObject::ScriptLogItem.
               show_items(to_display, expand_script, params['quiet'].value).join("\n")
    end
  end

  mode 'log:system' do
    logging_options(self)

    option 'source' do
      argument :optional
      default 'all'
      description 'Only display logs matching this source (default: all logs)'
    end

    # TODO: add option for quieting/verbosing log messages?

    def run
      response = dispatch(:logs_list, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
      else
        puts Scalr::ResponseObject::LogItem.
                 show_items(response.content, params['source'].value).join("\n")
      end
    end
  end

  mode 'launch' do
    description 'Launch a whole farm, or launch a server within a role'

    option 'farm, -a' do
      argument :optional
      description 'Farm to launch'
    end

    option 'role, -r' do
      argument :optional
      description 'Farm role to launch'
    end

    def run
      options = Scalr::Caller.collect_options(params, [:farm_id, :farm_role_id])
      action = nil
      action = :farm_launch   if options[:farm_id]
      action = :server_launch if options[:farm_role_id]
      if action.nil?
        raise "Must provide either 'farm' or 'role' to launch"
      end

      response = invoke(action, options)
      return if generic_error(response)

      if action == :farm_launch
        puts "Result: #{response.content}"
      else
        puts "Server ID: #{response.content}"
      end
    end

  end

  mode 'terminate' do
    description 'Terminate a server'

    option 'farm, -a' do
      argument :required
      description 'Farm "server" argument is in'
    end

    argument 'server' do
      description 'Server alias to terminate (e.g., "rails.1")'
    end

    def run
      response = dispatch(:server_terminate, params)
      return if generic_error(response)
      puts "Server #{response.request_inputs['ServerID']} - result: #{response.content}"
    end
  end

  mode 'exterminate' do
    def run
      puts <<-DALEK.gsub(/^ {6}/, '')
                 EX-TER-MIN-ATE!
                   /
              ___ /
      D>=G==='   '.
            |======|
            |======|
        )--/]IIIIII]
           |_______|
           C O O O D
          C O  O  O D
         C  O  O  O  D
         C__O__O__O__D
        [_____________]
      DALEK
    end
  end

  mode 'application:list' do
    description 'List available applications and their sources'

    def run
      application_response = invoke(:dm_applications_list)
      source_response = invoke(:dm_sources_list)
      return if generic_error(application_response) || generic_error(source_response)

      sources = Scalr::ResponseObject::SourceItem.
                    as_hash(source_response.content)
      puts Scalr::ResponseObject::Application.
               show_items(application_response.content, sources).join("\n")
    end
  end

  mode 'farm' do
    description 'Details about roles and other data within a farm'

    option 'farm, -a' do
      argument :required
      description 'Farm to fetch details for'
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      farm_id = response.request_inputs['FarmID']
      aliases = Scalr.aliases('farm', farm_id.to_s)

      puts "FARM: #{farm_id} (aliases: #{aliases.empty? ? 'N/A' : aliases.join(', ')})"
      puts '========================================'
      puts response.content.map {|farm_role| farm_role.for_display}.join("\n")
    end
  end

  mode 'farm:server' do
    description 'Find out on which role a server lives within a farm'

    option 'farm, -a' do
      description 'Farm containing server'
      argument :required
    end

    option 'server' do
      description 'Server to find (must be GUID)'
      argument :required
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      server_role = response.content.find do |role|
        role.servers.any? {|server| params['server'].value == server.id}
      end
      if server_role.nil?
        puts 'Cannot find server in farm.'
      else
        aliases = Scalr.aliases('role', server_role.name)
        puts "Role: #{server_role.name} (ID: #{server_role.id}) (aliases: #{aliases.empty? ? 'N/A' : aliases.join(', ')})"
      end
    end

  end

  mode 'farm:list' do
    description 'List summary of all farms'

    def run
      response = invoke(:farms_list)
      return if generic_error(response)
      puts Scalr::ResponseObject::FarmSummary.show_items(response.content).join("\n")
    end
  end

  mode 'config:get' do
    description <<-CONFIG.gsub(/^\s+/, '')
      Retrieve all configuration variables for a farm as key-value pairs,
      or fetch a single variable as a string suitable for shell-inclusion.
    CONFIG

    option 'farm, -a' do
      argument :required
      description 'Farm to get configuration from'
    end

    argument 'key' do
      argument :optional
      description <<-KEY.gsub(/^\s+/, '')
        Optional name of config key for which you want the value only;
        if not given we'll display all keys and values
      KEY
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'NO CONFIG FOUND'
      elsif matching_key = params['key'].value
        found = response.content.detect {|pair| pair.key_equals?(matching_key)}
        puts found.value if found
      else
        puts Scalr::ResponseObject::Variable.show_items(response.content).join("\n")
      end
    end

  end

  mode 'config:set' do
    description 'Assign a key/value configuration pair to a farm.'

    option 'farm, -a' do
      argument :required
      description "Farm to which we'll assign configuration"
    end

    argument 'pair' do
      arity -1
      description <<-PAIRS.gsub(/^\s+/, '')
        One or more key=value pairs for assignment; example: TTM_HEADPHONES=sennheiser. May also pass
        a filename of key/value pairs, one per line -- for example, output of 'config:get' works fine.
      PAIRS
    end

    def run
      options = Scalr::Caller.collect_options(params, [:farm_id])
      pairs = Scalr::ResponseObject::Variable.read(params['pair'].values)
      if pairs.empty?
        raise 'Must provide at least one key=value pair'
      end
      pairs.each do |pair|
        response = invoke(:global_variable_set, options.merge(param_name: pair.name, param_value: pair.value))
        if response.success?
          puts "OK #{pair.to_s}"
        else
          puts "FAIL #{pair.to_s} => #{response.error}"
        end
      end
    end
  end

  mode 'script' do
    description 'Display details about a script'

    option 'script' do
      argument :required
      description 'ID of script to display'
    end

    def run
      response = dispatch(:script_get_details, params)
      return if generic_error(response)

      puts Scalr::ResponseObject::Script.
               show_items(response.content).reverse.join("\n")
    end
  end

  mode 'script:list' do
    description 'Display available scripts'

    option 'display_all' do
      description 'true if you want to display all scripts, false to display only TTM scripts'
    end

    def run
      response = dispatch(:scripts_list, params)
      return if generic_error(response)

      puts Scalr::ResponseObject::ScriptSummary.
               show_items(response.content, params['display_all'].value).join("\n")
    end
  end

  mode 'ssh' do
    description 'Generate SSH command to connect to a specific server within a farm and role.'

    option 'farm, -a' do
      argument :required
      description 'Farm containing role + server'
    end

    option 'role, -r' do
      argument :optional
      description 'Role with server, required unless using role name with "server" arg'
    end

    argument 'server' do
      description 'Server index to use with role, or "role.index" name (e.g., "rails.2")'
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      server = Scalr::ResponseObject::FarmRole.
                 single_server(response.content, params['server'].value)

      unless server
        $stderr.puts("Failed to identify server with: #{params['server'].value}")
        exit_status 1
        return
      end

      farm_id = response.request_inputs['FarmID']
      key_path = File.expand_path("~/.ssh/FARM-#{farm_id}.#{server.platform_properties.availability_zone_brief}.private.pem")
      if File.exists?(key_path)
        puts "ssh -i #{key_path} root@#{server.external_ip}"
      else
        $stderr.puts(<<-KEYFILE.gsub(/^ {10}/, ''))

          Expected key file (#{key_path}) does not exist. Download it by:
            - going to https://my.scalr.com/#/sshkeys/view
            - find the row with the 'Farm ID' column as #{farm_id}
            - click the 'Actions' dropdown in its far right column
            - choose 'Download private key'
            - store it to #{key_path}
            - execute: 'chmod 400 #{key_path}' (so ssh won't complain about permissive permissions)
        KEYFILE
        exit_status 1
      end
    end
  end

  mode 'psql' do
    description 'Connect to a Scalr database via psql command line.'

    argument 'db' do
      arity 1
      description 'Database descriptor, one of: master, 1, 2, 3, 4, one, two, three, four; default: master'
      default 'master'
    end

    option 'farm, -a' do
      argument :required
      description 'Farm with database configurations'
    end

    option 'url' do
      cast :bool
      default false
      description 'true if you want to output a URL, false (default) to include "psql" in the output'
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      key = db_key(params['db'].value)
      pair = response.content.find{|var| var.key_equals?(key)}
      if pair
        external_url = pair.value.gsub(/int/, 'ext')
        puts(params['url'].value ? external_url : "psql #{external_url}")
      else
        similar_pairs = response.content.
            find_all {|var| var.key_matches?(/^TTM.+URL$/)}.
            map{|var| var.to_s}.
            join("\n  ")
        $stderr.puts <<-MISSING.gsub(/^ {11}/, '')
           DB CONFIG NOT FOUND!

           No such DB config key exists [Tried: #{key}]. If you're looking for a shard
           connection use one of 1..4 or 'one'..'four' as the shard identifier.

           Similar config keys from your farm:
             #{similar_pairs}
        MISSING
      end
    end

    def url_master
      'TTM_DATABASE_URL'
    end

    def url_shard(shard)
      "TTM_SHARD_#{shard}_URL"
    end

    def db_key(db)
      words = %w(ONE TWO THREE FOUR)
      return url_master if db == 'master'
      shard_count = db.to_i
      replacement = (1..4).include?(shard_count) ? words[shard_count - 1] : db.upcase
      url_shard(replacement)
    end
  end
}
