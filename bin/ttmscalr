#!/usr/bin/env ruby

# format of invocation:
#
# ttmscalr [command] [option...] -a application
# cribbed this from 'heroku' binary...

# resolve bin path, ignoring symlinks
require 'pathname'
bin_path = Pathname.new(__FILE__).realpath

# add self to libpath
$:.unshift File.expand_path('../../lib', bin_path)

require 'date'
require 'json'
require 'main'
require 'scalr'
require 'scalr/ttm'

Scalr.read_access_info
#Scalr.debug = $stdout

ALIAS_FILE = '~/.ttm_scalr_aliases.json'

# hardcoded (a) they shouldn't change, and (b) we're only using them for convenient aliasing
FARM_ALIASES = {
  '14433' => [ 'Prod-DB-Primary' ],
  '14460' => [ 'Prod-DB-Shard1' ],
  '14462' => [ 'Prod-DB-Shard2' ],
  '14463' => [ 'Prod-DB-Shard3' ],
  '14464' => [ 'Prod-DB-Shard4' ],
  '14498' => [ 'Production', 'ttm-production' ],
  '15163' => [ 'DB-Test' ],
  '15274' => [ 'PG-TEST' ],
  '15275' => [ 'Review', 'ttm-review', 'ttm-staging' ]
}

def farm_aliases
  read_aliases unless @farm_aliases
  @farm_aliases
end

# aliases stored in ~/.ttmscalr_aliases as JSON
# format:
#   'farm_aliases': {
#     'id': ['name', 'name'...]
#   },
#   'farm_role_aliases': {
#     'id' : ['name', 'name'...]
#   }
def read_aliases
  alias_path = File.expand_path(ALIAS_FILE)
  if File.exists?(alias_path)
    all_aliases = JSON.parse(IO.read(alias_path))
    @farm_aliases      = all_aliases['farm_aliases'] || {}
    @farm_role_aliases = all_aliases['farm_role_aliases'] || {}
  else
    @farm_aliases      = FARM_ALIASES
    @farm_role_aliases = {}
  end
  downcase_values = ->((_,v)) {v.collect! {|name| name.downcase}}
  @farm_aliases.each &downcase_values
  @farm_role_aliases.each &downcase_values
end

def farm_role_aliases
  read_aliases unless @farm_role_aliases
  @farm_role_aliases
end

def match_alias(alias_map, name)
  name_compare = name.downcase
  mapped = alias_map.find {|_, aliases| aliases.include?(name_compare)}
  mapped.empty? ? name : mapped.first
end

def generic_error(response)
  return true unless response
  return false if response.success?
  puts "Error! [Code: #{response.code}] [Message: #{response.error}]"
  true
end

def resolve_farm(name)
  return name if name.match(/^\d+$/) || farm_aliases.keys.include?(name)
  match_alias(farm_aliases, name)
end

def resolve_farm_status(status)
  return 'RUNNING'       if status == 1
  return 'TERMINATED'    if status == 0
  return 'TERMINATING'   if status == 2
  return 'SYNCHRONIZING' if status == 3
  return "UNKNOWN - #{status}"
end

def resolve_log_severity(level)
  level = level.to_i
  return 'DEBUG'   if level == 1
  return 'INFO'    if level == 2
  return 'WARNING' if level == 3
  return 'ERROR'   if level == 4
  return 'FATAL'   if level == 5
  "UNKNOWN (#{level})"
end

# returns an array of farm role IDs
def resolve_farm_role(name, params)
  role_names = []
  if farm_role_aliases.keys.include?(name)
    role_names << name
  elsif name != 'all'
    role_names << match_alias(farm_role_aliases, name)
  end

  response = dispatch(:farm_get_details, params)
  return [] unless response.success?

  response.content.
      find_all {|role_info| name == 'all' || role_names.include?(role_info[:name])}.
      map {|role_info| role_info[:id]}
end

# example of data structure: http://wiki.scalr.com/display/docs/FarmGetDetails
def show_role(role_info)
  servers = role_info[:serverset].nil? ? ['None'] : show_servers(role_info[:serverset])
  <<-ROLEINFO
  ROLE: #{role_info[:name]}
    Farm role ID:  #{role_info[:id]}  (Role ID: #{role_info[:role_id] || 'N/A'})
    Scaling:       #{show_scaling(role_info)}
    Instance type: #{role_info[:platformproperties][:instancetype]}
    Servers:
      #{servers.join("\n      ")}
  ROLEINFO
end

def build_pattern(items, keys, template)
  lengths = scan_lengths(items, keys)
  lengths.each do |key, length|
    template = template.gsub(/\{#{key}\}/, "#{length}s")
  end
  template
end

def scan_lengths(items, keys)
  Hash[ keys.map {|key| [key, items.map {|item| item[key].nil? ? 0 : item[key].length }.max ]} ]
end

def show_scaling(info)
  return '' unless info[:scalingproperties] && info[:isscalingenabled]
  p = info[:scalingproperties]
  if info[:isscalingenabled].to_i > 0
    "YES [Range: #{p[:mininstances]}-#{p[:maxinstances]}]"
  else
    "NO"
  end
end

def show_servers(server_items)
  return ['None'] unless server_items[:item]
  servers = server_items[:item].instance_of?(Array) ? server_items[:item] : [server_items[:item]]
  pat = build_pattern(servers, [:index, :status, :uptime, :serverid],
                      '#%-{index}. %{status} - Uptime %{uptime} - %{serverid}')
  servers.sort_by{|info| info[:index]}.map do |info|
    sprintf(pat, info[:index], info[:status], info[:uptime], info[:serverid])
  end
end

# to save typing we map parameters to shorter names
#   Scalr API name   => Our short name
PARAM_ALIASES = {
    application_id:     :application,
    farm_id:            :farm,
    records_limit:      :limit,
    remote_path:        :path,
    farm_role_id:       :role,
    server_id:          :server,
    start_from:         :start,
    deployment_task_id: :task,
}

def map_parameter_key(key)
  PARAM_ALIASES[key.to_sym] || key.to_sym
end

# allow use of either our short name or Scalr API name
def collect_options(api_names, params)
  options = {}
  api_names.each do |api_name|
    cli_name = map_parameter_key(api_name)
    first_value = first_value_for(params, cli_name, api_name)
    value = transform_value(api_name, first_value, params)
    options[api_name] = value if value
  end
  options
end

def first_value_for(params, *keys)
  keys.each do |key|
    option = option_by_name(params, key)
    if option
      value = option.values.length > 1 ? option.values : option.value
      return value if value
    end
  end
  nil
end

# Note that we're using params.find vs params['name'] because
# the latter kills the program (weird!)
def option_by_name(params, name)
  params.find {|option| option.name.to_s == name.to_s}
end

# allow transformations/lookups of data from the user
def transform_value(name, value, params)
  if name == :farm_id && ! value.nil?
    resolve_farm(value)
  elsif name == :farm_role_id && option_by_name(params, 'farm') && ! value.nil?
    roles = resolve_farm_role(value, params)
    if roles.empty?
      raise "Cannot resolve farm role [Farm: #{params['farm'].value}] [Role: #{value}]"
    else
      roles.first
    end
  else
    value
  end
end

def dispatch(action_name, params)
  request_info = Scalr::Request.action(action_name)
  raise "Unknown action [Given: #{action_name.to_s}]" unless request_info
  options = collect_options(request_info[:inputs].keys, params)
  scalr_call(action_name, options)
end

def scalr_call(action_name, options = {})
  begin
    Scalr.send(action_name, options)
  rescue Scalr::Request::InvalidInputError => e
    puts "ERROR: #{e.message}"
    nil
  end
end

# implementation notes:
# - Main seems to dispatch on mode-names in first-match order. So you'll need
#   to have a mode 'deploy' before a mode 'deploy:log', otherwise it will never
#   get invoked. So least-specific modes should be before most-specific.

Main {

  description <<-DESC
  Command-line interface for Scalr, with TTM-specific additions. See README.md for more.
  DESC


  ########## Deployment

  mode 'deploy' do
    option 'application' do
      argument :required
      description 'ID of application to deploy'
    end
    option 'farm' do
      argument :optional
      description 'Farm to use when resolving role (if aliased)'
    end
    option 'path' do
      argument :optional
      description 'Path to which the application will be deployed'
    end
    option 'role' do
      argument :required
      description 'ID/alias of farm role to which we will deploy the application'
    end

    def run
      response = dispatch(:dm_application_deploy, params)
      return if generic_error(response)

      puts response.inspect
    end
  end

  mode 'deploy:log' do
    option 'task' do
      argument :required
      description 'ID of deployment task'
    end
    def run
      response = dispatch(:dm_deployment_task_get_log, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
        return
      end

      response.content.each do |log_item|
        next if log_item.nil?
        time = Time.at(log_item[:timestamp].to_i).strftime('%H:%M:%S')
        message = log_item[:message].gsub( /[\r\n]/, ' ').rstrip
        puts "#{time} - #{message}"
      end
    end
  end

  mode 'deploy:status' do
    option 'task' do
      argument :required
      description 'ID of deployment task'
    end
    def run
      response = dispatch(:dm_deployment_task_get_status, params)
      return if generic_error(response)
      puts "Status: #{response.content}"
    end
  end

  mode 'deploy:tasks' do
    option 'application' do
      argument :optional
      description 'ID of application'
    end
    option 'farm' do
      argument :optional
      description 'ID of farm role'
    end
    option 'role' do
      argument :optional
      description 'ID of farm role'
    end
    option 'server' do
      argument :optional
      description 'ID server'
    end

    def run
      response = dispatch(:dm_deployment_tasks_list, params)
      return if generic_error(response)

      # return: serverid, deploymenttaskid, farmroleid, remotepath, status (no time?!)
      pat = build_pattern(response.content, [:deploymenttaskid, :farmroleid, :serverid, :status],
                          '%-{deploymenttaskid} - %-{status} [Server: %s]')
      response.content.each do |task_item|
        puts sprintf(pat, task_item[:deploymenttaskid], task_item[:status], task_item[:serverid])
      end
    end
  end

  mode 'logs:script' do
    option 'farm' do
      argument :required
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end
    option 'expand' do
      argument :optional
    end

    # TODO: add option for quieting/verbosing log messages

    def run
      response = dispatch(:script_logs_list, params)
      return if generic_error(response)

      expand_script = params['expand'].given? ? params['expand'].value : nil

      # each record has: message, timestamp, scriptname, exectime, execexitcode, event, serverid
      pat = build_pattern(response.content, [:scriptname, :execexitcode, :exectime],
                          '%s - %-{scriptname} - [Exit: %{execexitcode}] [Exec time: %{exectime}] [From event: %s]')
      response.content.each do |log_item|
        time = Time.at(log_item[:timestamp].to_i).strftime('%d %b %H:%M:%S')
        message = log_item[:message].nil? ? '' : log_item[:message].strip
        from_event = log_item[:event] || 'N/A'
        puts sprintf(pat, time, log_item[:scriptname], log_item[:execexitcode],
                          log_item[:exectime], from_event)
        if log_item[:execexitcode].to_i != 0 || ( expand_script && expand_script == log_item[:scriptname])
          puts message, "\n\n"
        end
      end
    end
  end

  mode 'logs:list' do
    option 'farm' do
      argument :required
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end

    # TODO: add option for quieting/verbosing log messages; filtering on source name

    def run
      response = dispatch(:logs_list, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
        return
      end

      # each record has: message, severity, timestamp, source, serverid
      pat = build_pattern(response.content, [:source], '%s - %-{source} - [Severity: %s]')
      response.content.each do |log_item|
        time = Time.at(log_item[:timestamp].to_i).strftime('%d %b %H:%M:%S')
        message = log_item[:message].nil? ? '' : log_item[:message].strip
        source = log_item[:source] || 'N/A'
        puts sprintf(pat, time, source, resolve_log_severity(log_item[:severity]))
        puts message
      end
    end
  end

  mode 'launch' do
    description 'Launch a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'role' do
      argument :optional
      description 'Farm role to launch'
    end

    def run

      options = collect_options([:farm_id, :farm_role_id], params)
      action = nil
      action = :farm_launch   if options[:farm_id]
      action = :server_launch if options[:farm_role_id]
      if action.nil?
        raise "Must provide either 'farm' or 'role' to launch"
      end


      response = scalr_call(action, options)
      return if generic_error(response)

      if action == :farm_launch
        puts "Result: #{response.content}"
      else
        puts "Server ID: #{response.content}"
      end
    end

  end


  mode 'terminate' do
    description 'Terminate a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'server' do
      argument :optional
      description 'Server ID to launch'
    end

    def run
      options = collect_options([:farm_id, :server_id], params)
      action  = nil
      action = :farm_terminate   if options[:farm_id]
      action = :server_terminate if options[:server_id]
      if action.nil?
        raise "Must provide either 'farm' or 'server' to terminate"
      end

      response = scalr_call(action, options)
      return if generic_error(response)

      puts "Result: #{response.content}"
    end
  end

  mode 'applications' do
    def run
      response = scalr_call(:dm_applications_list)
      return if generic_error(response)
      pat = build_pattern(response.content, [:name, :id, :source_id],
                          "%-{name} [Application ID: %{id}] [Source ID: %{source_id}]")
      response.content.each do |item|
        puts sprintf(pat, item[:name], item[:id], item[:sourceid])
      end
    end
  end

  mode 'farm' do
    description 'Details about roles and other data within a farm'
    option 'farm' do
      argument :required
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      response.content.each do |role_info|
        puts show_role(role_info)
      end
    end
  end

  mode 'farms' do
    description 'List all farms'

    def run
      response = scalr_call(:farms_list)
      return if generic_error(response)

      pat = build_pattern(response.content, [:id, :name, :status], '%{id}: %-{name} %{status}')
      response.content.each do |farm_info|
        status = resolve_farm_status(farm_info[:status].to_i)
        puts sprintf(pat, farm_info[:id], farm_info[:name], status)
      end
    end
  end

  mode 'config:get' do

    description <<-CONFIG
    Retrieve all configuration variables for a farm as key-value pairs,
    or a single variable as a string suitable for shell-inclusion.
    CONFIG

    option 'farm' do
      argument :required
      description 'Farm to get configuration from'
    end

    argument 'key' do
      argument :optional
      description 'Name of config key for which you want the value'
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'NO CONFIG FOUND'
      elsif params['key'].value
        found = response.content.detect {|pair| pair[:name] == params['key'].value}
        if found
          puts found[:value]
        end
      else
        response.content.each do |pair|
          puts sprintf('%-25s: %s', pair[:name], pair[:value])
        end
      end
    end

  end

  mode 'config:set' do
    description 'Assign a key/value configuration pair to a farm.'

    option 'farm' do
      argument :required
    end

    argument 'pair' do
      arity -1
      description <<-PAIRS
      Key=value pairs for assignment; example: TTM_HEADPHONES=sennheiser. May also pass a filename
      of key/value pairs, one per line -- for example, output of 'config:get' works fine.
      PAIRS
    end

    def run
      options = collect_options([:farm_id, :farm_role_id], params)
      pairs = read_pairs(params['pair'])
      if pairs.empty?
        raise 'Must provide at least one key=value pair'
      end
      pairs.each do |pair|
        response = scalr_call(:global_variable_set, options.merge(param_name: pair[0], param_value: pair[1]))
        pair_display = pair.join('=')
        if response.success?
          puts "OK #{pair_display}"
        else
          puts "FAIL #{pair_display} => #{response.error}"
        end
      end
    end

    def read_pairs(param)
      if param.values.length == 1 && File.exists?(param.value)
        File.readlines(param.value).map {|line| to_pair(line)}.compact
      else
        param.values.map {|entry| to_pair(entry)}.compact
      end
    end

    def to_pair(line)
      line = line.chomp
      return nil if line =~ /^\s*#/ || line =~ /^\s*$/
      key, value = line.split( /\s*[\=\:]\s*/, 2)
      [key, value]
    end
  end
}
