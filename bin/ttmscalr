#!/usr/bin/env ruby

# format of invocation:
#
# ttmscalr [command] [option...] -a application
# cribbed this from 'heroku' binary...

# resolve bin path, ignoring symlinks
require 'pathname'
bin_path = Pathname.new(__FILE__).realpath

# add self to libpath
$:.unshift File.expand_path('../../lib', bin_path)

require 'date'
require 'json'
require 'main'
require 'scalr'
require 'scalr/ttm'

Scalr.read_access_info
#Scalr.debug = $stdout

ALIAS_FILE = '~/.ttm_scalr_aliases.json'

# hardcoded (a) they shouldn't change, and (b) we're only using them for convenient aliasing
FARM_ALIASES = {
  '14433' => %w(Prod-DB-Primary db-master),
  '14460' => %w(Prod-DB-Shard1 db1),
  '14462' => %w(Prod-DB-Shard2 db2),
  '14463' => %w(Prod-DB-Shard3 db3),
  '14464' => %w(Prod-DB-Shard4 db4),
  '14498' => %w(Production ttm-production),
  '15163' => %w(DB-Test),
  '15274' => %w(PG-TEST),
  '15275' => %w(Review ttm-review ttm-staging)
}

def farm_aliases
  read_aliases unless Scalr.has_aliases?('farm')
  Scalr.aliases('farm')
end

def farm_role_aliases
  read_aliases unless Scalr.has_aliases?('role')
  Scalr.aliases('role')
end

# aliases stored in ~/.ttmscalr_aliases as JSON
# format:
#   'farm_aliases': {
#     'id': ['name', 'name'...]
#   },
#   'farm_role_aliases': {
#     'id' : ['name', 'name'...]
#   }
def read_aliases
  alias_path = File.expand_path(ALIAS_FILE)
  if File.exists?(alias_path)
    all_aliases = JSON.parse(IO.read(alias_path))
    farm_aliases      = all_aliases['farm_aliases'] || {}
    farm_role_aliases = all_aliases['farm_role_aliases'] || {}
  else
    farm_aliases      = FARM_ALIASES
    farm_role_aliases = {}
  end

  farm_aliases.each {|k,v| Scalr.add_alias('farm', k, v)}
  farm_role_aliases.each {|k,v| Scalr.add_alias('role', k, v)}
end

def match_alias(alias_map, name)
  name_compare = name.downcase
  mapped = alias_map.find {|_, aliases| aliases.include?(name_compare)}
  mapped.empty? ? name : mapped.first
end

def generic_error(response)
  return true unless response
  return false if response.success?
  puts "Error! [Code: #{response.code}] [Message: #{response.error}]"
  true
end

def resolve_farm(name)
  return name if name.match(/^\d+$/) || farm_aliases.keys.include?(name)
  match_alias(farm_aliases, name)
end

# returns an array of farm role IDs
def resolve_farm_role(name, params, response = nil)
  role_names = []
  if farm_role_aliases.keys.include?(name)
    role_names << name
  elsif name != 'all'
    role_names << match_alias(farm_role_aliases, name)
  end

  unless response
    response = dispatch(:farm_get_details, params)
    return [] unless response.success?
  end

  response.content.
      find_all {|role_info| name == 'all' || role_names.include?(role_info[:name])}.
      map {|role_info| role_info[:id]}
end

# given a count of a server within a role, resolve it to a fully-qualified
# server ID (GUID)
def resolve_server_index(index, params, role_id = nil)
  response = dispatch(:farm_get_details, params)
  return nil unless response.success?

  # if we have a role available to disambiguate, use it
  if role_id
    role = response.content.find {|role_info| role_id.to_s == role_info[:id]}
    unless role
      raise "No role with ID #{role_id} exists in farm #{params['farm'].value}"
    end
    servers = role.servers
  elsif option_by_name(params, 'role') && params['role'].given?
    role_ids = resolve_farm_role(params['role'].value, params, response)
    puts "Resolved role to #{role_ids.inspect}"
    servers = response.content.find {|role_info| role_ids.include?(role_info[:id])}.servers
  else
    servers = response.content.flat_map {|role_info| role_info.servers}
  end

  puts "Server after resolution: #{servers}"

  matching = servers.find_all {|server| index == server.index}

  # if too many, remove non-running ones
  if matching.length > 1
    matching = servers.find_all {|server| server.running?}
  end

  # if STILL too many you probably didn't assign a role...
  if matching.length > 1
    raise "Too many servers match index '#{index}' within the farm! Specify a role to disambiguate."
  end

  matching.empty? ? nil : matching.first.id
end

# example of data structure: http://wiki.scalr.com/display/docs/FarmGetDetails
def show_role(farm_role)
  servers = farm_role.servers.empty? ? ['None'] : show_servers(farm_role.servers)
  <<-ROLEINFO
  ROLE: #{farm_role.name}
    Farm role ID:  #{farm_role.id}  (Role ID: #{farm_role.role_id || 'N/A'})
    Scaling:       #{show_scaling(farm_role)}
    Platform:      #{farm_role.platform_properties.to_s}
    Servers:
      #{servers.join("\n      ")}
  ROLEINFO
end

def build_pattern(items, keys, template)
  lengths = scan_lengths(items, keys)
  lengths.each do |key, length|
    template = template.gsub(/\{#{key}\}/, "#{length}s")
  end
  template
end

def item_length(item)
  item.instance_of?(Fixnum) || item.instance_of?(Float) ? item.to_s.length : item.length
end

def scan_lengths(items, keys)
  Hash[ keys.map {|key| [key, items.map {|item| item[key].nil? ? 0 : item_length(item[key]) }.max ]} ]
end

def show_scaling(info)
  return '' unless info.scaling_properties && info.is_scaling
  p = info.scaling_properties
  if info.is_scaling.to_i > 0
    "YES [Range: #{p.min_instances}-#{p.max_instances}]"
  else
    "NO"
  end
end

def show_servers(servers)
  pat = build_pattern(servers, [:index, :status, :uptime, :id],
                      '#%-{index}. %{status} - Uptime %{uptime} - %{id} - %s')
  servers.sort_by{|info| info.index}.map do |info|
    sprintf(pat, info.index, info.status, info.uptime, info.id, info.platform_properties.to_s)
  end
end

# to save typing we map parameters to shorter names
#   Scalr API name   => Our short name
PARAM_ALIASES = {
    application_id:     :application,
    farm_id:            :farm,
    records_limit:      :limit,
    remote_path:        :path,
    farm_role_id:       :role,
    script_id:          :script,
    server_id:          :server,
    start_from:         :start,
    deployment_task_id: :task,
}

def map_parameter_key(key)
  PARAM_ALIASES[key.to_sym] || key.to_sym
end

# allow use of either our short name or Scalr API name
def collect_options(api_names, params)
  options = {}
  api_names.each do |api_name|
    cli_name = map_parameter_key(api_name)
    first_value = first_value_for(params, cli_name, api_name)
    value = transform_value(api_name, first_value, params)
    options[api_name] = value if value
  end
  options
end

def first_value_for(params, *keys)
  keys.each do |key|
    option = option_by_name(params, key)
    if option
      value = option.values.length > 1 ? option.values : option.value
      return value if value
    end
  end
  nil
end

# Note that we're using params.find vs params['name'] because
# the latter kills the program (weird!)
def option_by_name(params, name)
  params.find {|option| option.name.to_s == name.to_s}
end

# allow transformations/lookups of data from the user
def transform_value(name, value, params)
  if name == :farm_id && ! value.nil?
    resolve_farm(value)
  elsif name == :farm_role_id && option_by_name(params, 'farm') && ! value.nil?
    roles = resolve_farm_role(value, params)
    if roles.empty?
      raise "Cannot resolve farm role [Farm: #{params['farm'].value}] [Role: #{value}]"
    else
      roles.first
    end
  elsif name == :server_id
    if match_info = value.match(/^(\w+)\.(\d+)$/) # heroku format
      role_name = match_info[1]
      server_index = match_info[2]
      roles = resolve_farm_role(role_name, params)
      if roles.empty?
        raise "Cannot resolve farm role [Farm: #{params['farm'].value}] [Role: #{role_name}]"
      end
      server_guid = resolve_server_index(server_index, params, roles.first)
      if server_guid.nil?
        raise "Cannot resolve server index to GUID [Farm: #{params['farm'].value}] [Role/server: #{value}]"
      end
      server_guid
    elsif name == :server_id && value.to_s.length < 4
      server_guid = resolve_server_index(value, params)
      if server_guid.nil?
        raise "Cannot resolve server index to GUID [Farm: #{params['farm'].value}] [Role: #{params['role'].value}] [Server index: #{value}]"
      end
      server_guid
    else
      value
    end
  else
    value
  end
end

def dispatch(action_name, params)
  request_info = Scalr::Request.action(action_name)
  raise "Unknown action [Given: #{action_name.to_s}]" unless request_info
  options = collect_options(request_info[:inputs].keys, params)
  scalr_call(action_name, options)
end

def scalr_call(action_name, options = {})
  begin
    Scalr.send(action_name, options)
  rescue Scalr::Request::InvalidInputError => e
    puts "ERROR: #{e.message}"
    nil
  end
end

# implementation notes:
# - Main seems to dispatch on mode-names in first-match order. So you'll need
#   to have a mode 'deploy' before a mode 'deploy:log', otherwise it will never
#   get invoked. So least-specific modes should be before most-specific.

Main {

  description <<-DESC
  Command-line interface for Scalr, with TTM-specific additions. See README.md for more.
  DESC


  ########## Deployment

  mode 'deploy' do
    option 'application' do
      argument :required
      description 'ID of application to deploy'
    end
    option 'farm' do
      argument :optional
      description 'Farm to use when resolving role (if aliased)'
    end
    option 'path' do
      argument :optional
      description 'Path to which the application will be deployed'
    end
    option 'role' do
      argument :required
      description 'ID/alias of farm role to which we will deploy the application'
    end

    def run
      response = dispatch(:dm_application_deploy, params)
      return if generic_error(response)

      puts response.inspect
    end
  end

  mode 'deploy:log' do
    option 'task' do
      argument :required
      description 'ID of deployment task'
    end
    def run
      response = dispatch(:dm_deployment_task_get_log, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
        return
      end

      response.content.each do |log_item|
        next if log_item.nil?
        time = Time.at(log_item[:timestamp].to_i).strftime('%H:%M:%S')
        message = log_item[:message].gsub( /[\r\n]/, ' ').rstrip
        puts "#{time} - #{message}"
      end
    end
  end

  mode 'deploy:status' do
    option 'task' do
      argument :required
      description 'ID of deployment task'
    end
    def run
      response = dispatch(:dm_deployment_task_get_status, params)
      return if generic_error(response)
      puts "Status: #{response.content}"
    end
  end

  mode 'deploy:tasks' do
    option 'application' do
      argument :optional
      description 'ID of application'
    end
    option 'farm' do
      argument :optional
      description 'ID of farm role'
    end
    option 'role' do
      argument :optional
      description 'ID of farm role'
    end
    option 'server' do
      argument :optional
      description 'ID server'
    end

    def run
      response = dispatch(:dm_deployment_tasks_list, params)
      return if generic_error(response)

      # return: serverid, deploymenttaskid, farmroleid, remotepath, status (no time?!)
      pat = build_pattern(response.content, [:task_id, :server_id, :status],
                          '%-{task_id} - %-{status} [Server: %s]')
      response.content.each do |task_item|
        puts sprintf(pat, task_item.task_id, task_item.status, task_item.server_id)
      end
    end
  end

  mode 'log:script' do
    option 'farm' do
      argument :required
    end
    option 'role' do
      argument :optional
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end
    option 'expand' do
      argument :optional
    end
    option 'verbose' do
      argument :optional
      cast :bool
      default false
    end

    def run
      response = dispatch(:script_logs_list, params)
      return if generic_error(response)

      expand_script = params['expand'].given? ? params['expand'].value : nil

      display_all = params['verbose'].value

      puts "Script logs -- displaying #{display_all ? 'all records' : 'only failures'}", "\n"

      to_display = display_all ? response.content : response.content.find_all {|log_item| log_item.failure?}
      pat = build_pattern(to_display, [:script_name, :exit_code, :exec_time, :event],
                          '%s - %-{script_name} - [Exit: %{exit_code}] [Exec time: %{exec_time}] [From event: %-{event}] [Server: %s]')
      to_display.each do |log_item|
        next unless log_item.failure? || display_all
        message = log_item.message.nil? ? '' : log_item.message.strip
        from_event = log_item.event || 'N/A'
        puts sprintf(pat, log_item.timestamp_formatted, log_item.script_name, log_item.exit_code,
                          log_item.exec_time, from_event, log_item.server_id)
        if log_item.failure? || log_item.script_matches(expand_script)
          puts message, "\n\n"
        end
      end
    end
  end

  mode 'log:list' do
    option 'farm' do
      argument :required
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end
    option 'source' do
      argument :optional
      default 'all'
    end
    option 'verbose' do
      argument :optional
      cast :bool
      default false
    end

    # TODO: add option for quieting/verbosing log messages; filtering on source name

    def run
      response = dispatch(:logs_list, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
        return
      end

      # each record has: message, severity, timestamp, source, serverid
      pat = build_pattern(response.content, [:source], '%s - %-{source} - [Severity: %s]')
      response.content.each do |log_item|
        next unless log_item.matches_source(params['source'].value)
        message = log_item.message.nil? ? '' : log_item.message.strip
        source = log_item.source || 'N/A'
        puts sprintf(pat, log_item.timestamp_formatted, source, log_item.severity_formatted)
        puts message if params['verbose'].value
      end
    end
  end

  mode 'launch' do
    description 'Launch a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'role' do
      argument :optional
      description 'Farm role to launch'
    end

    def run
      options = collect_options([:farm_id, :farm_role_id], params)
      action = nil
      action = :farm_launch   if options[:farm_id]
      action = :server_launch if options[:farm_role_id]
      if action.nil?
        raise "Must provide either 'farm' or 'role' to launch"
      end


      response = scalr_call(action, options)
      return if generic_error(response)

      if action == :farm_launch
        puts "Result: #{response.content}"
      else
        puts "Server ID: #{response.content}"
      end
    end

  end


  mode 'terminate' do
    description 'Terminate a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'server' do
      argument :optional
      description 'Server ID to launch'
    end

    def run
      options = collect_options([:farm_id, :server_id], params)
      action  = nil
      action = :farm_terminate   if options[:farm_id]
      action = :server_terminate if options[:server_id]
      if action.nil?
        raise "Must provide either 'farm' or 'server' to terminate"
      end
      if action == :farm_terminate
        raise "Sorry, Andre won't let us run this yet!"
      end

      response = scalr_call(action, options)
      return if generic_error(response)

      puts "Result: #{response.content}"
    end
  end

  mode 'application:list' do
    def run
      response = scalr_call(:dm_applications_list)
      return if generic_error(response)
      pat = build_pattern(response.content, [:name, :id, :source_id],
                          '%-{name} [Application ID: %{id}] [Source ID: %s]')
      response.content.each do |item|
        puts sprintf(pat, item.name, item.id, item.source_id)
      end
    end
  end

  mode 'farm' do
    description 'Details about roles and other data within a farm'
    option 'farm' do
      argument :required
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      response.content.each do |farm_role|
        puts show_role(farm_role)
      end
    end
  end

  mode 'farm:list' do
    description 'List all farms'

    def run
      response = scalr_call(:farms_list)
      return if generic_error(response)

      pat = build_pattern(response.content, [:id, :name, :status], '%{id}: %-{name} - %s')
      response.content.each do |farm_info|
        puts sprintf(pat, farm_info.id, farm_info.name, farm_info.status_formatted)
      end
    end
  end

  mode 'config:get' do

    description <<-CONFIG
    Retrieve all configuration variables for a farm as key-value pairs,
    or a single variable as a string suitable for shell-inclusion.
    CONFIG

    option 'farm' do
      argument :required
      description 'Farm to get configuration from'
    end

    argument 'key' do
      argument :optional
      description 'Name of config key for which you want the value'
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'NO CONFIG FOUND'
      elsif params['key'].value
        found = response.content.detect {|pair| pair[:name] == params['key'].value}
        if found
          puts found[:value]
        end
      else
        response.content.each do |pair|
          puts sprintf('%-25s: %s', pair[:name], pair[:value])
        end
      end
    end

  end

  mode 'config:set' do
    description 'Assign a key/value configuration pair to a farm.'

    option 'farm' do
      argument :required
    end

    argument 'pair' do
      arity -1
      description <<-PAIRS
      Key=value pairs for assignment; example: TTM_HEADPHONES=sennheiser. May also pass a filename
      of key/value pairs, one per line -- for example, output of 'config:get' works fine.
      PAIRS
    end

    def run
      options = collect_options([:farm_id, :farm_role_id], params)
      pairs = read_pairs(params['pair'])
      if pairs.empty?
        raise 'Must provide at least one key=value pair'
      end
      pairs.each do |pair|
        response = scalr_call(:global_variable_set, options.merge(param_name: pair[0], param_value: pair[1]))
        pair_display = pair.join('=')
        if response.success?
          puts "OK #{pair_display}"
        else
          puts "FAIL #{pair_display} => #{response.error}"
        end
      end
    end

    def read_pairs(param)
      if param.values.length == 1 && File.exists?(param.value)
        File.readlines(param.value).map {|line| to_pair(line)}.compact
      else
        param.values.map {|entry| to_pair(entry)}.compact
      end
    end

    def to_pair(line)
      line = line.chomp
      return nil if line =~ /^\s*#/ || line =~ /^\s*$/
      key, value = line.split( /\s*[\=\:]\s*/, 2)
      [key, value]
    end
  end

  mode 'script' do
    option 'script' do
      argument :required
    end

    def run
      response = dispatch(:script_get_details, params)
      return if generic_error(response)

      pat = build_pattern(response.content, [:revision], '%s, v%-{revision} - Config: %s')
      response.content.reverse.each do |script_rev|
        puts sprintf(pat, script_rev.date_formatted, script_rev.revision, script_rev.config_variables_formatted('none'))
      end
    end
  end

  mode 'script:list' do
    option 'display_all' do
      cast :bool
      default false
    end

    def run
      response = dispatch(:scripts_list, params)
      return if generic_error(response)

      pat = build_pattern(response.content, [:id, :description, :name], '%-{id} %-{name} - %s')
      response.content.each do |script_item|
        next unless params['display_all'].value || script_item.ttm?
        puts sprintf(pat, script_item.id, script_item.name, script_item.description)
      end
    end
  end

  mode 'ssh' do
    option 'farm' do
      argument :required
    end

    option 'role' do
      argument :required
    end

    argument 'server' do

    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      farm_id = response.request_inputs['FarmID']
      response.content.each do |role|
        server = role.find_server(params['server'].value)
        if server
          key_path = File.expand_path("~/.ssh/FARM-#{farm_id}.#{server.platform_properties.availability_zone_brief}.private.pem")
          if File.exists?(key_path)
            puts "ssh -i #{key_path} root@#{server.external_ip}"
          else
            $stderr.puts("Expected key file (#{key_path}) does not exist.")
          end
        end
      end
    end
  end
}
