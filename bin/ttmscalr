#!/usr/bin/env ruby

# format of invocation:
#
# ttmscalr [command] [option...] -a application
# cribbed this from 'heroku' binary...

# resolve bin path, ignoring symlinks
require 'pathname'
bin_path = Pathname.new(__FILE__).realpath

# add self to libpath
$:.unshift File.expand_path('../../lib', bin_path)

require 'date'
require 'json'
require 'main'
require 'scalr'
require 'scalr/ttm'

Scalr.read_access_info
#Scalr.debug = $stderr

ALIAS_FILE = '~/.ttm_scalr_aliases.json'

def farm_aliases
  read_aliases unless Scalr.has_aliases?('farm')
  Scalr.aliases('farm')
end

def farm_role_aliases
  read_aliases unless Scalr.has_aliases?('role')
  Scalr.aliases('role')
end

# aliases stored in ~/.ttmscalr_aliases as JSON
# format:
#   'farm_aliases': {
#     'id': ['name', 'name'...]
#   },
#   'farm_role_aliases': {
#     'id' : ['name', 'name'...]
#   }
def read_aliases
  return true if Scalr.has_aliases?('farm') && Scalr.has_aliases?('role')

  alias_path = File.expand_path(ALIAS_FILE)
  unless File.exists?(alias_path)
    $stderr.puts <<-ALIASHELP.gsub(/^ {6}/, '')
      You do not currently have a file for scalr aliases. It will make your life much easier!
      Creating one for you now in #{alias_path}...
    ALIASHELP
    File.open(alias_path, 'w') do |out|
      out.puts <<-DEFAULTALIASES.gsub(/^ {6}/, '')
      {
        "farm_aliases": {
          "15356": [ "Prod-DB-Primary", "master" ],
          "15357": [ "Prod-DB-Shard1", "shard1" ],
          "15358": [ "Prod-DB-Shard2", "shard2" ],
          "15359": [ "Prod-DB-Shard3", "shard3" ],
          "15360": [ "Prod-DB-Shard4", "shard4" ],
          "14498": [ "Production", "ttm-production" ],
          "15163": [ "DB-Test" ],
          "15274": [ "PG-TEST" ],
          "15275": [ "Review", "ttm-review", "ttm-staging" ],
          "15331": [ "Winters" ]
        },
        "farm_role_aliases": {
          "RailsAppServer" : ["web", "rails"],
          "Sidekiq"        : ["sidekiq"],
          "Bunchball"      : ["bunchball", "bb"],
          "SystemWatcher"  : ["watcher"],
          "Reports"        : ["reports"],
          "DevDebug"       : ["debug"]
        }
      }
      DEFAULTALIASES
    end
    $stderr.puts "DONE - file written. Let's go!"
  end
  all_aliases = JSON.parse(IO.read(alias_path))
  farm_aliases      = all_aliases['farm_aliases'] || {}
  farm_role_aliases = all_aliases['farm_role_aliases'] || {}

  farm_aliases.each {|k,v| Scalr.add_alias('farm', k, v)}
  farm_role_aliases.each {|k,v| Scalr.add_alias('role', k, v)}
  true
end

def generic_error(response)
  return true unless response
  return false if response.success?
  $stderr.puts("ERROR - #{response.error}]")
  true
end

def resolve_farm(farm_alias)
  read_aliases
  return farm_alias if farm_alias.match(/^\d+$/) || Scalr.is_aliased_name?('farm', farm_alias)
  Scalr.match_alias('farm', farm_alias)
end

# returns an array of farm role IDs
def resolve_farm_role(name, params, response = nil)
  read_aliases
  role_names = []
  if Scalr.is_aliased_name?('role', name)
    role_names << name
  elsif name != 'all'
    role_names << Scalr.match_alias('role', name)
  end

  unless response
    response = dispatch(:farm_get_details, params)
    unless response.success?
      $stderr.puts('Failed to get farm details!')
      generic_error(response)
      return []
    end
  end

  response.content.
      find_all {|role_info| name == 'all' || role_names.include?(role_info.name.downcase)}.
      map {|role_info| role_info.id}
end

# given a count of a server within a role, resolve it to a fully-qualified
# server ID (GUID)
def resolve_server_index(index, params, role_id = nil)
  response = dispatch(:farm_get_details, params)
  return nil unless response.success?

  # if we have a role available to disambiguate, use it
  if role_id
    role = response.content.find {|role_info| role_id.to_s == role_info[:id]}
    unless role
      raise "No role with ID #{role_id} exists in farm #{params['farm'].value}"
    end
    servers = role.servers
  elsif option_by_name(params, 'role') && params['role'].given?
    role_ids = resolve_farm_role(params['role'].value, params, response)
    servers = response.content.find {|role_info| role_ids.include?(role_info[:id])}.servers
  else
    servers = response.content.flat_map {|role_info| role_info.servers}
  end

  matching = servers.find_all {|server| index == server.index}

  # if too many, remove non-running ones
  if matching.length > 1
    matching = servers.find_all {|server| server.running?}
  end

  # if STILL too many you probably didn't assign a role...
  if matching.length > 1
    raise "Too many servers match index '#{index}' within the farm! Specify a role to disambiguate."
  end

  matching.empty? ? nil : matching.first.id
end

def build_pattern(items, keys, template)
  lengths = scan_lengths(items, keys)
  lengths.each do |key, length|
    template = template.gsub(/\{#{key}\}/, "#{length}s")
  end
  template
end

def item_length(item)
  item.instance_of?(Fixnum) || item.instance_of?(Float) ? item.to_s.length : item.length
end

def scan_lengths(items, keys)
  Hash[ keys.map {|key| [key, items.map {|item| item[key].nil? ? 0 : item_length(item[key]) }.max ]} ]
end

def single_server(roles, server_spec)
  servers = Scalr::ResponseObject::FarmRole.find_servers(roles, server_spec)
  return servers.first if servers.length == 1

  if servers.empty?
    $stderr.puts('No such server found!')
  else
    $stderr.puts('Multiple servers identified:')
    $stderr.puts(Scalr::ResponseObject::Server.show(servers).join("\n"))
  end
  nil
end

# to save typing we map parameters to shorter names
#   Scalr API name   => Our short name
PARAM_ALIASES = {
    application_id:     :application,
    farm_id:            :farm,
    records_limit:      :limit,
    remote_path:        :path,
    farm_role_id:       :role,
    script_id:          :script,
    server_id:          :server,
    start_from:         :start,
    deployment_task_id: :task,
}

def map_parameter_key(key)
  PARAM_ALIASES[key.to_sym] || key.to_sym
end

# allow use of either our short name or Scalr API name
def collect_options(api_names, params)
  options = {}
  api_names.each do |api_name|
    cli_name = map_parameter_key(api_name)
    first_value = first_value_for(params, cli_name, api_name)
    value = transform_value(api_name, first_value, params)
    options[api_name] = value if value
  end
  options
end

def first_value_for(params, *keys)
  keys.each do |key|
    option = option_by_name(params, key)
    if option
      value = option.values.length > 1 ? option.values : option.value
      return value if value
    end
  end
  nil
end

# Note that we're using params.find vs params['name'] because
# the latter kills the program (weird!)
def option_by_name(params, name)
  params.find {|option| option.name.to_s == name.to_s}
end

# allow transformations/lookups of data from the user
def transform_value(name, value, params)
  if name == :farm_id && ! value.nil?
    resolve_farm(value)
  elsif name == :farm_role_id && option_by_name(params, 'farm') && ! value.nil?
    roles = resolve_farm_role(value, params)
    if roles.empty?
      raise "Cannot resolve farm role [Farm: #{params['farm'].value}] [Role: #{value}]"
    else
      roles.first
    end
  elsif name == :server_id && ! value.nil?
    if match_info = value.match(/^(\w+)\.(\d+)$/) # heroku format
      role_name = match_info[1]
      server_index = match_info[2]
      roles = resolve_farm_role(role_name, params)
      if roles.empty?
        raise "Cannot resolve farm role [Farm: #{params['farm'].value}] [Role: #{role_name}]"
      end
      server_guid = resolve_server_index(server_index, params, roles.first)
      if server_guid.nil?
        raise "Cannot resolve server index to GUID [Farm: #{params['farm'].value}] [Role/server: #{value}]"
      end
      server_guid
    elsif name == :server_id && value.to_s.length < 4
      server_guid = resolve_server_index(value, params)
      if server_guid.nil?
        raise "Cannot resolve server index to GUID [Farm: #{params['farm'].value}] [Role: #{params['role'].value}] [Server index: #{value}]"
      end
      server_guid
    else
      value
    end
  else
    value
  end
end

def dispatch(action_name, params)
  request_info = Scalr::Request.action(action_name)
  raise "Unknown action [Given: #{action_name.to_s}]" unless request_info
  options = collect_options(request_info[:inputs].keys, params)
  scalr_call(action_name, options)
end

def scalr_call(action_name, options = {})
  begin
    Scalr.send(action_name, options)
  rescue Scalr::Request::InvalidInputError => e
    $stderr.puts("ERROR: #{e.message}")
    nil
  end
end

# implementation notes:
# - Main seems to dispatch on mode-names in first-match order. So you'll need
#   to have a mode 'deploy' before a mode 'deploy:log', otherwise it will never
#   get invoked. So least-specific modes should be before most-specific.

Main {

  description <<-DESC
  Command-line interface for Scalr, with TTM-specific additions. See README.md for more.
  DESC


  ########## Deployment

  mode 'deploy' do
    option 'application' do
      argument :required
      description 'ID of application to deploy. (Use "application:list" to list.)'
    end
    option 'farm, -a' do
      argument :optional
      description 'Farm to use when resolving role (if aliased)'
    end
    option 'path' do
      argument :optional
      description 'Path to which the application will be deployed (rarely needed)'
    end
    option 'role' do
      argument :required
      description 'Role to which the application will be deployed'
    end

    def run
      response = dispatch(:dm_application_deploy, params)
      return if generic_error(response)

      puts response.inspect
    end
  end

  mode 'deploy:tasks' do
    option 'application' do
      argument :optional
      description 'ID of application'
    end
    option 'farm' do
      argument :optional
      description 'ID of farm role'
    end
    option 'role' do
      argument :optional
      description 'ID of farm role'
    end
    option 'server' do
      argument :optional
      description 'ID server'
    end

    def run
      response = dispatch(:dm_deployment_tasks_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'No task records.'
      else
        # return: serverid, deploymenttaskid, farmroleid, remotepath, status (no time?!)
        pat = build_pattern(response.content, [:task_id, :server_id, :status],
                            '%-{task_id} - %-{status} [Server: %s]')
        response.content.each do |task_item|
          puts sprintf(pat, task_item.task_id, task_item.status, task_item.server_id)
        end
      end
    end
  end

  mode 'task' do
    option 'task' do
      argument :required
      description 'ID of deployment task (use "deploy:tasks" + farm and role to lookup)'
    end

    def run
      response = dispatch(:dm_deployment_task_get_status, params)
      return if generic_error(response)

      puts "Status: #{response.content}"

      response = dispatch(:dm_deployment_task_get_log, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
      else
        response.content.each do |log_item|
          puts "#{log_item.timestamp_formatted} - #{log_item.message_trimmed}"
        end
      end
    end

  end

  mode 'log:script' do
    option 'farm' do
      argument :required
    end
    option 'role' do
      argument :optional
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end
    option 'expand' do
      argument :optional
    end
    option 'verbose' do
      argument :optional
      cast :bool
      default false
    end

    def run
      response = dispatch(:script_logs_list, params)
      return if generic_error(response)

      expand_script = params['expand'].given? ? params['expand'].value : nil

      display_all = params['verbose'].value

      puts "Script logs -- displaying #{display_all ? 'all records' : 'only failures'}", "\n"

      to_display = display_all ? response.content : response.content.find_all {|log_item| log_item.failure?}
      pat = build_pattern(to_display, [:script_name, :exit_code, :exec_time, :event],
                          '%s - %-{script_name} - [Exit: %{exit_code}] [Exec time: %{exec_time}] [From event: %-{event}] [Server: %s]')
      to_display.each do |log_item|
        next unless log_item.failure? || display_all
        message = log_item.message.nil? ? '' : log_item.message.strip
        from_event = log_item.event || 'N/A'
        puts sprintf(pat, log_item.timestamp_formatted, log_item.script_name, log_item.exit_code,
                          log_item.exec_time, from_event, log_item.server_id)
        if log_item.failure? || log_item.script_matches(expand_script)
          puts message, "\n\n"
        end
      end
    end
  end

  mode 'log:list' do
    option 'farm' do
      argument :required
    end
    option 'server' do
      argument :optional
    end
    option 'start' do
      argument :optional
    end
    option 'limit' do
      argument :optional
    end
    option 'source' do
      argument :optional
      default 'all'
    end
    option 'verbose' do
      argument :optional
      cast :bool
      default false
    end

    # TODO: add option for quieting/verbosing log messages; filtering on source name

    def run
      response = dispatch(:logs_list, params)
      return if generic_error(response)

      if response.value[:totalrecords].to_i == 0
        puts 'No log records'
        return
      end

      # each record has: message, severity, timestamp, source, serverid
      pat = build_pattern(response.content, [:source], '%s - %-{source} - [Severity: %s]')
      response.content.each do |log_item|
        next unless log_item.matches_source(params['source'].value)
        message = log_item.message.nil? ? '' : log_item.message.strip
        source = log_item.source || 'N/A'
        puts sprintf(pat, log_item.timestamp_formatted, source, log_item.severity_formatted)
        puts message if params['verbose'].value
      end
    end
  end

  mode 'launch' do
    description 'Launch a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'role' do
      argument :optional
      description 'Farm role to launch'
    end

    def run
      options = collect_options([:farm_id, :farm_role_id], params)
      action = nil
      action = :farm_launch   if options[:farm_id]
      action = :server_launch if options[:farm_role_id]
      if action.nil?
        raise "Must provide either 'farm' or 'role' to launch"
      end


      response = scalr_call(action, options)
      return if generic_error(response)

      if action == :farm_launch
        puts "Result: #{response.content}"
      else
        puts "Server ID: #{response.content}"
      end
    end

  end

  mode 'terminate' do
    description 'Terminate a Farm or Server'

    option 'farm' do
      argument :optional
      description 'Farm to launch'
    end

    option 'server' do
      argument :optional
      description 'Server ID to launch'
    end

    def run
      options = collect_options([:farm_id, :server_id], params)
      action  = nil
      action = :farm_terminate   if options[:farm_id]
      action = :server_terminate if options[:server_id]
      if action.nil?
        raise "Must provide either 'farm' or 'server' to terminate"
      end
      if action == :farm_terminate
        raise "Sorry, Andre won't let us run this yet!"
      end

      response = scalr_call(action, options)
      return if generic_error(response)

      puts "Result: #{response.content}"
    end
  end

  mode 'application:list' do
    def run
      application_response = scalr_call(:dm_applications_list)
      source_response = scalr_call(:dm_sources_list)
      return if generic_error(application_response) || generic_error(source_response)

      sources = Hash[ source_response.content.map{|si| [si.id, si.url]} ]

      pat = build_pattern(application_response.content, [:name, :id, :source_id],
                          '%-{name} [Application ID: %{id}] [Source: %s]')
      application_response.content.each do |item|
        source_url = sources[item.source_id]
        puts sprintf(pat, item.name, item.id, source_url)
      end
    end
  end

  mode 'farm' do
    description 'Details about roles and other data within a farm'

    option 'farm, -a' do
      argument :required
      description 'Farm to fetch details for'
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      farm_id = response.request_inputs['FarmID']
      read_aliases
      aliases = Scalr.aliases('farm', farm_id.to_s)

      puts "FARM: #{farm_id} (aliases: #{aliases.empty? ? 'N/A' : aliases.join(', ')})"
      puts '========================================'
      puts response.content.map {|farm_role| farm_role.for_display}.join("\n")
    end
  end

  mode 'farm:list' do
    description 'List summary of all farms'

    def run
      response = scalr_call(:farms_list)
      return if generic_error(response)

      read_aliases
      puts Scalr::ResponseObject::FarmSummary.show(response.content).join("\n")
    end
  end

  mode 'config:get' do

    description <<-CONFIG.gsub(/^\s+/, '')
    Retrieve all configuration variables for a farm as key-value pairs,
    or fetch a single variable as a string suitable for shell-inclusion.
    CONFIG

    option 'farm, -a' do
      argument :required
      description 'Farm to get configuration from'
    end

    argument 'key' do
      argument :optional
      description 'Optional name of config key for which you want the value, if not given will display all'
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      if response.content.nil? || response.content.empty?
        puts 'NO CONFIG FOUND'
      elsif matching_key = params['key'].value
        found = response.content.detect {|pair| pair.key_equals?(matching_key)}
        puts found.value if found
      else
        puts Scalr::ResponseObject::Variable.show(response.content).join("\n")
      end
    end

  end

  mode 'config:set' do
    description 'Assign a key/value configuration pair to a farm.'

    option 'farm, -a' do
      argument :required
      description "Farm to which we'll assign configuration"
    end

    argument 'pair' do
      arity -1
      description <<-PAIRS.gsub(/^\s+/, '')
        One or more key=value pairs for assignment; example: TTM_HEADPHONES=sennheiser. May also pass
        a filename of key/value pairs, one per line -- for example, output of 'config:get' works fine.
      PAIRS
    end

    def run
      options = collect_options([:farm_id], params)
      pairs = Scalr::ResponseObject::Variable.read(params['pair'].values)
      if pairs.empty?
        raise 'Must provide at least one key=value pair'
      end
      pairs.each do |pair|
        response = scalr_call(:global_variable_set, options.merge(param_name: pair.name, param_value: pair.value))
        if response.success?
          puts "OK #{pair.to_s}"
        else
          puts "FAIL #{pair.to_s} => #{response.error}"
        end
      end
    end
  end

  mode 'script' do
    description 'Display details about a script'

    option 'script' do
      argument :required
      description 'ID of script to display'
    end

    def run
      response = dispatch(:script_get_details, params)
      return if generic_error(response)

      puts Scalr::ResponseObject::Script.
               show(response.content).reverse.join("\n")
    end
  end

  mode 'script:list' do
    description 'Display available scripts'

    option 'display_all' do
      cast :bool
      default false
      description 'true if you want to display all scripts, false to display only TTM scripts'
    end

    def run
      response = dispatch(:scripts_list, params)
      return if generic_error(response)

      display_all = params['display_all'].value
      puts Scalr::ResponseObject::ScriptSummary.
               show(response.content, display_all).join("\n")
    end
  end

  mode 'ssh' do
    description 'Generate SSH command to connect to a specific server within a farm and role.'

    option 'farm, -a' do
      argument :required
      description 'Farm containing role + server'
    end

    option 'role' do
      argument :optional
      description 'Role with server, required unless using role name with "server" arg'
    end

    argument 'server' do
      description 'Server index to use with role, or "role.index" name (e.g., "rails.2")'
    end

    def run
      response = dispatch(:farm_get_details, params)
      return if generic_error(response)

      server = single_server(response.content, params['server'].value)

      unless server
        $stderr.puts("Failed to identify server with: #{params['server'].value}")
        exit_status 1
        return
      end

      farm_id = response.request_inputs['FarmID']
      key_path = File.expand_path("~/.ssh/FARM-#{farm_id}.#{server.platform_properties.availability_zone_brief}.private.pem")
      if File.exists?(key_path)
        puts "ssh -i #{key_path} root@#{server.external_ip}"
      else
        $stderr.puts("Expected key file (#{key_path}) does not exist.")
        exit_status 1
      end
    end
  end

  mode 'psql' do
    description 'Connect to a Scalr database via psql command line.'

    argument 'db' do
      arity 1
      description 'Database descriptor, one of: master, 1, 2, 3, 4, one, two, three, four; default: master'
      default 'master'
    end

    option 'farm, -a' do
      argument :required
      description 'Farm with database configurations'
    end

    option 'url' do
      cast :bool
      default false
      description 'true if you want to output a URL, false (default) to include "psql" in the output'
    end

    def run
      response = dispatch(:global_variables_list, params)
      return if generic_error(response)

      key = db_key(params['db'].value)
      pair = response.content.find{|var| var.key_equals?(key)}
      if pair
        external_url = pair.value.gsub(/int/, 'ext')
        puts(params['url'].value ? external_url : "psql #{external_url}")
      else
        similar_pairs = response.content.
            find_all {|var| var.key_matches?(/^TTM.+URL$/)}.
            map{|var| var.to_s}.
            join("\n  ")
        $stderr.puts <<-MISSING.gsub(/^ {11}/, '')
           DB CONFIG NOT FOUND!

           No such DB config key exists [Tried: #{key}]. If you're looking for a shard
           connection use one of 1..4 or 'one'..'four' as the shard identifier.

           Similar config keys from your farm:
             #{similar_pairs}
        MISSING
      end
    end

    def url_master
      'TTM_DATABASE_URL'
    end

    def url_shard(shard)
      "TTM_SHARD_#{shard}_URL"
    end

    def db_key(db)
      words = %w(ONE TWO THREE FOUR)
      return url_master if db == 'master'
      shard_count = db.to_i
      replacement = (1..4).include?(shard_count) ? words[shard_count - 1] : db.upcase
      url_shard(replacement)
    end
  end
}
